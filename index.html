<html>
    <head>
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">
        <link rel="stylesheet" href="lib/css/zenburn.css">
<style>
    .reveal pre code {
        max-height: none
    } 
    .reveal .manualcode {
        background-color: #3F3F3F
    }
    .reveal .highlight {
        color: #4788FB
    }
</style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>Observing Everything</h1>
                    <h2>Completely Reactive Apps in the Real World with RxSwift</h2>
                </section>
                <section>
                    <h3>Zova - a fitness app</h3>
                    <aside class="notes">
                        <p>What does this entail:</p>
                        <ul>
                            <li>At first: a video player for workouts</li>
                            <li>Then, a companion watch application</li>
                            <li>Then, a faux-pt</li>
                            <li>Then, a scoring mechanism</lib>
                        </ul>
                    </aside>
                    
                </section>
                <section>
                    <h3>Initially objective-c</h3>
                    <p>Standard iOS app - standard object orientated design</p>
                    <aside class="notes">There was nothing wrong with the application, it folloed the typical mvc pattern laid out by apple. However this typically results in:</aside>
                </section>
                <section>
                    <img src="images/state_everywhere.jpg" />
                </section>
                <section>
                    <pre><code class="hljs objectivec" data-trim>
@property NSMutableArray *sections;

- (instancetype)init
{
    self = [super init];
    _sections = [NSMutableArray new];
    
    for(int i = 0; i < 7; i++)
    {
      ZVCollectionViewNullSection *nullSection = [ZVCollectionViewNullSection new];
      [_sections addObject:nullSection];
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Standard iOS message passing and asynchrony solution:</h2>
                </section>
                <section>
                    <h2>There is none</h2>
                </section>
                <section>
                    <ul>
                        <li>NSNotificationCenter</li>
                        <li>Delegates</li>
                        <li>Callback closures</li>
                    </ul>
                </section>
                <section>
                    <pre><code class="hljs objectivec" data-trim>
self.timeObserver = [avPlayer addPeriodicTimeObserverForInterval:CMTimeMake(1, 10) 
    queue:NULL usingBlock:^(CMTime time)
        {
            NSTimeInterval timeInSeconds = CMTimeGetSeconds(time);
            
            if(timeInSeconds > 0 && [weakSelf.delegate
                respondsToSelector:@selector(videoPlayer:didPlayFrame:time:lastTime:)])
            {
                NSTimeInterval currentItemDuration = [weakSelf.player currentItemDuration];
                
                if(!isnan(currentItemDuration))
                {
                    [[NSNotificationCenter defaultCenter]
                        postNotificationName: kVKVideoPlayerDurationDidLoadNotification
                        object:weakSelf
                        userInfo:@{@"duration":[NSNumber numberWithDouble:currentItemDuration]}];
                    
                    [weakSelf.delegate videoPlayer:weakSelf
                        didPlayFrame:weakSelf.track time:timeInSeconds lastTime:0];
                }
            }
        }];
                    </code></pre>
                       <aside class="notes">Here's an example from the code I found using all three mechanisms at once. Pretty full on.
                           So with the rewrite to swift, came a good opportunity to make the app more functional. Now functional programming and mobile application development tend not to be two things you associate with each other. And for good reason, between the network requests, user input, animations, its pretty hard to keep your app adhering to functional paradigms outside of little snippets of maps and filters. So how can we reap the benefits of a more functional architecture?</aside>
                </section>
                <section>
                       <h1>ReactiveX</h1>
                       <img src="images/Rx_Logo_M.png" style="border: none; background: none;"/>
                       <aside class="notes">ReactiveX, or rx for short, is a library started by microsoft, initially for .net, now implemented for many (18 on the website at this time), including swift
                </section>
                <section>
                    <h1>An API for asynchronous programming with observable streams</h1>
                    <aside class="notes">Straight from the horses mouth. The Rx API combines the observer pattern with functional operators to allow what is known as Functional Reactive Programming.
                </section>
                <section>
                    <h2>The Observable</h2>
                    <p>An asynchronous value stream</p>
                    <img src="images/observable.png" />
                    <aside class="notes">At the heart of Rx is the observable. An observable defines a stream of values, which will arrive asynchronously over time. 
                        Observables are pure, computation of an observable does not have side effects.
                    </aside>
                </section>
                <section>
                    <p>A basic observable could be:</h2>
                    <ul>
                        <li>User tap events on a specific button</li>
                        <li>A network request</li>
                        <li>A database operation</li>
                        <li>Scroll offset in a scroll view as a user swipes</li>
                        <li>A timer</li>
                        <li>Anything!</li>
                    </ul>
                    <aside class="notes">Any kind of sequence of events can be modelled as an observable. It is not limited to certain kinds of operations. A core aspect of Rx is the ability to easily define new observables, which we'll get into later</aside>
                </section>
                <section>
                    <h2>Subscriptions</h2>
                   <aside class="notes">
                       As observables are pure, by themselves they're not incredibly useful to our users. They would just see white screens. Then probably rate the app 1 star. Not good.
                       To do some work based on our observable, we need to subscribe to it. In fact an observable wont even be computed unless it is subscribed to.
                        Subscribing to an observable is the process of attaching an observer, so that it recieves a notification of each new value emitted by the observable.
                        This is where your side effects will live.
                    </aside>
                    <pre><code class="hljs swift">
button.rx.tap //This is an observable
    .subscribe(onNext: { present(viewController: myAlert) }) //this is a side effect 
                    </code></pre> 
                </section>
                <section>
                    <h2>Disposal</h2>
                    <p>Manage the lifetime of your subscriptions</p>
                    <aside class="notes">Now when you define a subscription, you have created a description of what to do when something happens. But for how long? Well, until it is disposed. When you create a subscription, you are provided with a disposable object. This object is essentially a handle on your subscription. Once you call dispose on this handle, your subscription is over, and all observables created by your subscription are disposed,  Observables can define code to execute when they are disposed, which is useful when they are long running eg. cancelling network requests. 
                        RxSwift provides something called a disposeBag, which manages a collection of subscriptions. Once its refcount reaches zero and it is deinited, it will dispose every subscription it is storing.</aside>
                    <pre><code class="hljs swift">
let disposables = DisposeBag()

//Subscription will exist until tapDisposable.dispose()
let tapDisposable = button.rx.tap 
    .subscribe(onNext: { present(viewController: myAlert) })


tapDisposables.disposed(by: disposables) //disposables will call tapDisposable.dispose() on deinit
                    </code></pre> 
                </section>
                <section>
                    <h2>Using the DisposeBag</h2>
                    <aside class="notes">The great thing about observable disposal is that it chains. When a subscription is disposed, all observables that have been created within its chain are disposed. When used in conjuction with the DisposeBag, this means that we don't have to worry about screens leaking resources once they are gone.</aside>
                    <pre><code class="hljs swift">
class ViewController: UIViewController {
    let disposables = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        let tapDisposable = button.rx.tap 
            .subscribe(onNext: { present(viewController: myAlert) })
            .disposed(by: disposables)
    }
                    </code></pre>
                </section>
                <section>
                    <h2>Observable operators</h2>
                    <img src="images/map.png" />
                    <pre><code class="hljs swift">let newObservable = numberSource.map { $0 * 10 }</code></pre>
                    <aside class="notes">The observer pattern itself is nothing new. However Rx means Reactive extensions, and its at the x where things get interesting. Each Rx implementation ships with a variety of functional operators which can be applied to observables. These operators allow you to transform observables and combine them with each other in various ways, providing the building blocks for a functional and declarative codebase.</aside>
                </section>
                <section>
                    <h2>In practice</h2>
                    <aside class="notes">So now lets see how this works in practice. Lets say we were to build a login screen. A pretty standard affair, it gathers the user's username and password, ships them off to a backend API, and displays the result.</aside>
                    <img src="images/coolpeopleclub.png" />
                </section>
                <section>
                    <h2>Done!</h2>
                    <pre><code class="hljs swift">
class ViewController: UIViewController {
    let disposables = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        loginButton.rx.tap
            .withLatestFrom(
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            )
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
    }
</code></pre>
                </section>

                <section>
                    <h2>Done!</h2>
                    <pre class="manualcode">
class ViewController: UIViewController {
    let disposables = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        loginButton.rx.tap
            .withLatestFrom(
                <span class="highlight">Observable.combineLatest(nameField.rx.text, passwordField.rx.text)</span>
            )
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
    }
</pre>
                </section>
                <section>
                    <h2>Done!</h2>
                    <pre class="manualcode">
class ViewController: UIViewController {
    let disposables = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        <span class="highlight">loginButton.rx.tap
            .withLatestFrom(
                </span>Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            <span class="highlight">)</span>
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
    }
</pre>
                </section>
                <section>
                    <h2>Done!</h2>
                    <pre class="manualcode">
class ViewController: UIViewController {
    let disposables = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()

        loginButton.rx.tap
            .withLatestFrom(
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            )
            <span class="highlight">.flatMapLatest { userAPI.login(user: $0, password: $1) }</span>
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
    }
</pre>
                </section>
            </div>
        </div>
        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script>
            Reveal.initialize({
                    controls: false,
                    progress: true,
                    history: true,
                    center: true,
                    transition: 'slide', // none/fade/slide/convex/concave/zoom
                    width: "95%",
                    height: "95%",
                    margin: 0,
                    // More info https://github.com/hakimel/reveal.js#dependencies
                    dependencies: [
                        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                        { src: 'plugin/zoom-js/zoom.js', async: true },
                        { src: 'plugin/notes/notes.js', async: true }
                    ]
            });
    </script>
</body>
</html>
