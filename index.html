<html>
    <head>
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">
        <link rel="stylesheet" href="lib/css/zenburn.css">
<style>
    .reveal pre code {
        max-height: none
    } 
    .reveal .manualcode {
        background-color: #3F3F3F
    }
    .reveal .highlight {
        color: #4788FB
    }
    .reveal h4 {
        margin: 20px 0 0 30%;
        color: #4788FB;
        text-align: left;
    }
    .reveal .uncenter ul {
        margin: 0 0 0 30%;
            padding: 0 0 0 2em;
        text-align: left;
    } 
    .uncenter {
        text-align: left;
    }
    .reveal section img.coolPeopleClub {
        width: auto;
        height: 35%;
        display: inline-block;
        margin: 0 1%;
    }
</style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>Observing Everything</h1>
                    <h2>Completely Reactive Apps in the Real World with RxSwift</h2>
                </section>
                <section>
                    <h3>Zova - a fitness app</h3>
                    <aside class="notes">
                        <p>What does this entail:</p>
                        <ul>
                            <li>At first: a video player for workouts</li>
                            <li>Then, a companion watch application</li>
                            <li>Then, a faux-pt</li>
                            <li>Then, a scoring mechanism</lib>
                        </ul>
                    </aside>
                    
                </section>
                <section>
                    <h3>Initially objective-c</h3>
                    <p>Standard iOS app - standard object orientated design</p>
                    <aside class="notes">There was nothing wrong with the application, it folloed the typical mvc pattern laid out by apple. However this typically results in:</aside>
                </section>
                <section>
                    <img src="images/state_everywhere.jpg" />
                </section>
                <section>
                    <pre><code data-trim class="hljs objectivec" data-trim>
@property NSMutableArray *sections;

- (instancetype)init
{
    self = [super init];
    _sections = [NSMutableArray new];
    
    for(int i = 0; i < 7; i++)
    {
      ZVCollectionViewNullSection *nullSection = [ZVCollectionViewNullSection new];
      [_sections addObject:nullSection];
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Standard iOS message passing and asynchrony solution:</h2>
                </section>
                <section>
                    <h2>There is none</h2>
                </section>
                <section>
                    <h2>NSNotificationCenter</h2>
                    <h2>Delegates</h2>
                    <h2>Callback closures</h2>
                </section>
                <section>
                    <pre><code class="hljs objectivec" data-trim>
self.timeObserver = [avPlayer addPeriodicTimeObserverForInterval:CMTimeMake(1, 10) 
    queue:NULL usingBlock:^(CMTime time) {
        NSTimeInterval timeInSeconds = CMTimeGetSeconds(time);
        NSTimeInterval currentItemDuration = [weakSelf.player currentItemDuration];
            
        [[NSNotificationCenter defaultCenter]
            postNotificationName: kVKVideoPlayerDurationDidLoadNotification
            object:weakSelf
            userInfo:@{@"duration":[NSNumber numberWithDouble:currentItemDuration]}];
            
        [weakSelf.delegate videoPlayer:weakSelf
            didPlayFrame:weakSelf.track time:timeInSeconds lastTime:0];
    }];
                    </code></pre>
                       <aside class="notes">Here's an example from the code I found using all three mechanisms at once. Pretty full on.
                           So with the rewrite to swift, came a good opportunity to make the app more functional. Now functional programming and mobile application development tend not to be two things you associate with each other. And for good reason, between the network requests, user input, animations, its pretty hard to keep your app adhering to functional paradigms outside of little snippets of maps and filters. So how can we reap the benefits of a more functional architecture?</aside>
                </section>
                <section>
                       <h1>ReactiveX</h1>
                       <img src="images/Rx_Logo_M.png" style="border: none; background: none;"/>
                       <aside class="notes">ReactiveX, or rx for short, is a library started by microsoft, initially for .net, now implemented for many (18 on the website at this time), including swift
                </section>
                <section>
                    <h1>An API for asynchronous programming with observable streams</h1>
                    <aside class="notes">Straight from the horses mouth. The Rx API combines the observer pattern with functional operators to allow what is known as Functional Reactive Programming.
                </section>
                <section>
                    <h2>The Observable</h2>
                    <p>An asynchronous value stream</p>
                    <img src="images/observable.png" />
                    <aside class="notes">At the heart of Rx is the observable. An observable defines a stream of values, which will arrive asynchronously over time. It appears similar to an iterator, however rather than pulling values from it, it pushes them.  Observables are pure, computation of an observable does not have side effects.
                    </aside>
                </section>
                <section>
                    <p>A basic observable could be:</h2>
                    <ul>
                        <li>User tap events on a specific button</li>
                        <li>A network request</li>
                        <li>A database operation</li>
                        <li>Scroll offset in a scroll view as a user swipes</li>
                        <li>A timer</li>
                        <li>Anything!</li>
                    </ul>
                    <aside class="notes">Any kind of sequence of events can be modelled as an observable. It is not limited to certain kinds of operations. A core aspect of Rx is the ability to easily define new observables, which we'll get into later</aside>
                </section>
                <section>
                    <h2>Subscriptions</h2>
                   <aside class="notes">
                       As observables are pure, by themselves they're not incredibly useful to our users. They would just see white screens. Then probably rate the app 1 star. Not good.
                       To do some work based on our observable, we need to subscribe to it. In fact an observable wont even be computed unless it is subscribed to.
                        Subscribing to an observable is the process of attaching an observer, so that it recieves a notification of each new value emitted by the observable.
                        This is where your side effects will live.
                    </aside>
                    <pre><code data-trim class="hljs swift">
button.rx.tap //This is an observable
    .subscribe(onNext: { present(viewController: myAlert) }) //this is a side effect 
                    </code></pre> 
                </section>
                <section>
                    <h2>Observable operators</h2>
                    <img src="images/map.png" />
                    <aside class="notes">The observer pattern itself is nothing new. However Rx means Reactive extensions, and its at the x where things get interesting. Each Rx implementation ships with a variety of functional operators which can be applied to observables. These operators allow you to transform observables and combine them with each other in various ways, providing the building blocks for a functional and declarative codebase.</aside>
                </section>
                <section>
                    <h2>In practice</h2>
                    <aside class="notes">So now lets see how this works in practice. Lets say we were to build a login screen. A pretty standard affair, it gathers the user's username and password, ships them off to a backend API, and displays the result.</aside>
                    <img src="images/coolpeopleclub.png" />
                </section>
                <section>
                    <h2>Done!</h2>
                    <pre><code data-trim class="hljs swift"> loginButton.rx.tap
            .withLatestFrom(
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            )
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
    }
</code></pre>
                </section>
                <section>
                    <pre class="manualcode">
        loginButton.rx.tap
            .withLatestFrom(
                <span class="highlight">Observable.combineLatest(nameField.rx.text, passwordField.rx.text)</span>
            )
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
</pre>
                </section>
                <section>
                    <h2>combineLatest</h2>
                    <img src="images/combineLatest.png" />
                </section>
                <section>
                    <pre class="manualcode">
        loginButton.rx.tap
            <span class="highlight">.withLatestFrom(</span>
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            <span class="highlight">)</span>
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
</pre>
                </section>
                <section>
                    <h2>withLatestFrom</h2>
                    <img src="images/withLatestFrom.png" />
                </section>
                <section>
                    <pre class="manualcode">
        loginButton.rx.tap
            .withLatestFrom(
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            )
            <span class="highlight">.flatMapLatest { userAPI.login(user: $0, password: $1) }</span>
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
</pre>
                </section>
                <section>
                    <h2>flatMap/Latest</h2>
                    <img style="background: white;" src="images/flatMap.png" />
                </section>
                <section>
                    <h2>A functional reactive video player</h2>
                    <img src="images/videoplayer.png" style="height: 70%; width: auto;" />
                    <aside class="notes">Ok now lets move on to a more advanced example... like a workout video player. 
                    So the video player in this app, it has more than a few things going on. At the bottom of the pile you have the workout videos,
                    which is essentially the iOS AVPlayer widget being fed a playlist of streams to play.
                    Then either below it or overlayed, depending on screen orientation, we have the hud, showing what exercise you're on, what rep within that exercise, and what's coming up next, among other things.
                    And in between exercises we display intro segments, displaying info about the upcoming exercise, while actually pausing the video player underneath.
                    </aside>
                </section>
                <section>
                    <aside class="notes">Ok so there's a lot going on at this screen at once. We want to build a screen which displays information derived from the current state of the video player.  This calls for a reactive UI. The iOS video player exposes a variety of notifications to make it possible to build one around it. Unfortunately iOS doesn't help us here in that it uses three different mechanisms to notify the developer of changes to the video player's state. This is a place where rx shines, as we can encapsulate each of the notification mechanisms in observables, providing us with both a consistent api, and a library of functional operators with which to build our reactive ui.</aside>
                    <div class="uncenter">
                        <h4>Key-value observable</h4>
                        <ul>
                            <li>currentItem</li>
                            <li>isMuted</li>
                            <li>volume</li>
                            <li>status</li>
                        </ul>
                        <h4>Registered callbacks</h4>
                        <ul>
                            <li>Reached time</li>
                            <li>Periodic time</li>
                        </ul>
                        <h4>Broadcast notifications</h4>
                        <ul>
                            <li>Reached end of item</li> 
                            <li>Failed to play</li>
                            <li>Player skipped time</li>
                        </ul>
                    </div>
                </section>
                <section>
                    <h2>KVO -> Observable</h2>
                    <aside class="notes">RxSwift includes a number of ways to create observables. In this instance we're using the builtin observe method to wrap a kvo property. Note that its being implemented as an extension of the Reactive<AVPlayer> class itself using swift's protocol extensions constraints, meaning it can now be used as a property as if it was built into the framework itself</aside>
                    <pre><code data-trim class="hljs swift">
extension Reactive where Base: AVPlayer {
    public var currentItem: Observable&lt;AVPlayerItem&gt;{
        return observe(AVPlayerItem.self, "currentItem")
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>NSNotification -> Observable</h2>
                    <pre><code data-trim class="hljs swift">
extension Reactive where Base: AVPlayer {
    public var itemEnd: Observable&lt;NSNotification&gt; {
        return Observable.merge(
            notificationCenter.rx.notification(NSNotification.Name.AVPlayerItemDidPlayToEndTime),
            notificationCenter.rx.notification(NSNotification.Name.AVPlayerItemFailedToPlayToEndTime)
        )
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Callback -> Observable</h2>
                    <pre><code data-trim class="hljs swift">
extension Reactive where Base: AVPlayer {
    public func seekTime(scale: CMTime) -> Observable&lt;Double&gt; {
        return Observable.create { observer in
            let timeObserver = player.addPeriodicTimeObserver(forInterval: scale, queue: nil) {
                observer.on(.next($0.seconds))
            }
            return Disposables.create {
                player.removeTimeObserver(timeObserver)
            }
        }
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Now everything is simple</h2>
                <img src="images/everythingobservable.jpg" />
                </section>
                <section>
                    <aside class="notes">So this is how we would expose the name of the currently playing exercise.</aside>
                    <pre><code data-trim class="hljs swift">
class WorkoutPlayer {
    public lazy var currentExerciseName: Observable&lt;String&gt; = 
        Observable.combineLatest(self.workout, self.currentItem) { workout, currentItem in
            workout.exercises[currentItem.position].name
         }
}
            </code></pre>
                </section>
                <section>
                    <h2>The old fashioned way</h2>
                    <aside class="notes">As a comparison, here is the equivalent functionality implemented using plain old key value observing, as well as a delegate to notify the new exercise name. You can see that on top of outright being more code, we have to keep track of our two changing properties in variables. We all know that as the size and scale of the class increases, the number of variables that we need to track will increase inordinately with the data we want to derive.</aside> 
                    <pre><code data-trim class="hljs swift" style="font-size: 16px; line-height: 20px;">
protocol WorkoutPlayerDelegate {
    func exerciseNameChanged(name: String)
}

class WorkoutPlayer {
    var workout: Workout {
        didSet {
            updateCurrentExercise()
        }
    }
    var currentItem: WorkoutPlayerItem?
    
    func setupObserving() {
        let player = AVPlayer()
        addObserver(self, forKeyPath: #keyPath(player.currentItem), options: [.old, .new], context: nil)
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == #keyPath(player.currentItem) {
           currentItem = player.currentItem
           updateCurrentExercise()
        }
    }
    
    func updateCurrentExercise() {
        let exercise = workout.exercises[currentItem.position]
        delegate.exerciseNameChanged(name: exercise.name)
    }
    
    func unsetupObserving() {
        removeObserver(self, forKeyPath: #keyPath(player.currentItem))
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Score calculation</h2>
                    <aside class="notes">Another area of the app where usage of rx comes into its own is in our calculation of the user's activity score. The score is a number providing an insight into how active someone currently is as a whole. It calculates this by aggregating the user's activity from a variety of sources, and for each activity weighting it by its age, finally reducing the data together. What makes this interesting is that this data needs to be extracted from a multitude of sources asynchronously so as not to block the ui, with each source taking an undetermined amount of time to return. On top of that, the score is dependent on time, so we would like it to update as time passes. Just to add some more complication</aside>
                    <img src="images/score.png" style="height: 70%; width: auto; display: inline-block; vertical-align: middle;" />
                    <ul style="vertical-align: middle">
                        <li class="highlight">Healthkit (db)</li>
                        <ul>
                            <li>Workouts</li>
                            <li>Pedometer activity times</li>
                            <ul>
                                <li class="highlight">Motion coprocessor</li>
                                <ul>
                                    <li>Pedometer activity quality</li>
                                </ul>
                            </ul>
                        </ul>
                        <li class="highlight">Sqlite db</li>
                            <ul>
                                <li>Historic pedometer activity</li>
                            </ul>
                        <li class="highlight">Timeline API (until recently)</li>
                        <ul><li>Workouts</li></ul>
                    </ul>
                </section>
                <section>
                    <aside class="notes">And essentially, this is all it takes. Again we're using combineLatest to aggregate a variety of streams. We can then map this out of a timer which reflects the dates of 7 days ago to today, to ensure that our scoring range is always accurate to the minute. Again, we've achieved this without storing any state.</aside>
                    <pre><code data-trim class="hljs swift">
protocol ActivitySource {
    func activities(from: Date, to: Date) -&gt; Observable&lt;[ScorableActivity]&gt;
}
...

class Scorer {
    //  [healthkitWorkoutSource, pedometerSource, databaseSource, timelineSource]
    let sources: [ActivitySource] 

    var score: Observable&lt;Double&gt; {
        let weekToNow: Observable&lt;(Date, Date)&gt; =
            Observable&lt;Int&gt;.timer(0, period: 60, scheduler: MainScheduler.instance)
                .map { _ in Date().addingTimeInterval(-60 * 60 * 24 * 7) }

        let activities: Observable&lt;[ScorableActivity]&gt; = 
            weekToNow.flatMapLatest { from, to in 
                let activities: [Observable&lt;[ScorableActivity]&gt;]
                    = sources.map { $0.activities(from: from, to: to) }
                return Observable.combineLatest(activities) { $0.reduce([]) { $0 + $1 } } 
            }

        return activities.map { self.score(activities: $0) }
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Modelling a screen in all its states</h2>
                    <aside class="notes">Now it all comes to a crux with our ability to represent an entire screen as not just through a set of observables, but as a single observable. This is made possible with the usage of Swift's enums, which are sum types. This is a pattern we've been adopting lately for more complex screens. Lets take the homescreen again as an example. Let's go back to our hypothetical login screen for the lambdajam cool people club. Our user attempts to log in, upon which the app communicate with the backend and determine access. This doesn't happen instantly, so we want to reflect our loading state to the user. On top of that, maybe they're not cool enough to log in. Now lets go ahead and model this in a single, easy to follow observable</aside>
                    <img src="images/loading.png" class="coolPeopleClub" />
                    <img src="images/welcome.png" class="coolPeopleClub" />
                    <img src="images/notcool.png" class="coolPeopleClub" />
                </section>
                <section>
                    <pre><code data-trim class="hljs swift">
enum State {
    case loading, failed(message: String), welcome(name: String, friendRequests: Int)
}

//Just a recipe, no api requests are made until necessary
var welcomeState: Observable&lt;State&gt; {
   return Observable.zip(
        userAPI.getUserDetails(token),
        friendsAPI.getFriendRequests(token)
    ) { user, friendRequests in
        State.welcome(name: user.name, friendRequests: friendRequests.count)
    }
}

var state: Observable&lt;State&gt; {
    return loginRequest //from our previous example
        .flatMapLatest { result -&gt; Observable&lt;State&gt; in
            switch result {
            case .success(let token):
                return self.welcomeState
            case .failure(let error):
                return Observable.just(State.failed(message: error.message))
            }
        }
        .startWith(State.loading)
}
                    </code></pre>
            </div>
        </div>
        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script>
            Reveal.initialize({
                    controls: false,
                    progress: true,
                    history: true,
                    center: true,
                    transition: 'slide', // none/fade/slide/convex/concave/zoom
                    width: "95%",
                    height: "95%",
                    margin: 0,
                    // More info https://github.com/hakimel/reveal.js#dependencies
                    dependencies: [
                        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                        { src: 'plugin/zoom-js/zoom.js', async: true },
                        { src: 'plugin/notes/notes.js', async: true }
                    ]
            });
    </script>
</body>
</html>
