<html>
    <head>
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">
        <link rel="stylesheet" href="lib/css/zenburn.css">
<style>
    .reveal pre code {
        max-height: none
    } 
    .reveal .manualcode {
        background-color: #3F3F3F
    }
    .reveal .highlight {
        color: #4788FB
    }
    .reveal h4 {
        margin: 20px 0 0 30%;
        color: #4788FB;
        text-align: left;
    }
    .reveal .uncenter ul {
        margin: 0 0 0 30%;
            padding: 0 0 0 2em;
        text-align: left;
    } 
    .uncenter {
        text-align: left;
    }
</style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>Observing Everything</h1>
                    <h2>Completely Reactive Apps in the Real World with RxSwift</h2>
                </section>
                <section>
                    <h3>Zova - a fitness app</h3>
                    <aside class="notes">
                        <p>What does this entail:</p>
                        <ul>
                            <li>At first: a video player for workouts</li>
                            <li>Then, a companion watch application</li>
                            <li>Then, a faux-pt</li>
                            <li>Then, a scoring mechanism</lib>
                        </ul>
                    </aside>
                    
                </section>
                <section>
                    <h3>Initially objective-c</h3>
                    <p>Standard iOS app - standard object orientated design</p>
                    <aside class="notes">There was nothing wrong with the application, it folloed the typical mvc pattern laid out by apple. However this typically results in:</aside>
                </section>
                <section>
                    <img src="images/state_everywhere.jpg" />
                </section>
                <section>
                    <pre><code class="hljs objectivec" data-trim>
@property NSMutableArray *sections;

- (instancetype)init
{
    self = [super init];
    _sections = [NSMutableArray new];
    
    for(int i = 0; i < 7; i++)
    {
      ZVCollectionViewNullSection *nullSection = [ZVCollectionViewNullSection new];
      [_sections addObject:nullSection];
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Standard iOS message passing and asynchrony solution:</h2>
                </section>
                <section>
                    <h2>There is none</h2>
                </section>
                <section>
                    <h2>NSNotificationCenter</h2>
                    <h2>Delegates</h2>
                    <h2>Callback closures</h2>
                </section>
                <section>
                    <pre><code class="hljs objectivec" data-trim>
self.timeObserver = [avPlayer addPeriodicTimeObserverForInterval:CMTimeMake(1, 10) 
    queue:NULL usingBlock:^(CMTime time) {
        NSTimeInterval timeInSeconds = CMTimeGetSeconds(time);
        NSTimeInterval currentItemDuration = [weakSelf.player currentItemDuration];
            
        [[NSNotificationCenter defaultCenter]
            postNotificationName: kVKVideoPlayerDurationDidLoadNotification
            object:weakSelf
            userInfo:@{@"duration":[NSNumber numberWithDouble:currentItemDuration]}];
            
        [weakSelf.delegate videoPlayer:weakSelf
            didPlayFrame:weakSelf.track time:timeInSeconds lastTime:0];
    }];
                    </code></pre>
                       <aside class="notes">Here's an example from the code I found using all three mechanisms at once. Pretty full on.
                           So with the rewrite to swift, came a good opportunity to make the app more functional. Now functional programming and mobile application development tend not to be two things you associate with each other. And for good reason, between the network requests, user input, animations, its pretty hard to keep your app adhering to functional paradigms outside of little snippets of maps and filters. So how can we reap the benefits of a more functional architecture?</aside>
                </section>
                <section>
                       <h1>ReactiveX</h1>
                       <img src="images/Rx_Logo_M.png" style="border: none; background: none;"/>
                       <aside class="notes">ReactiveX, or rx for short, is a library started by microsoft, initially for .net, now implemented for many (18 on the website at this time), including swift
                </section>
                <section>
                    <h1>An API for asynchronous programming with observable streams</h1>
                    <aside class="notes">Straight from the horses mouth. The Rx API combines the observer pattern with functional operators to allow what is known as Functional Reactive Programming.
                </section>
                <section>
                    <h2>The Observable</h2>
                    <p>An asynchronous value stream</p>
                    <img src="images/observable.png" />
                    <aside class="notes">At the heart of Rx is the observable. An observable defines a stream of values, which will arrive asynchronously over time. It appears similar to an iterator, however rather than pulling values from it, it pushes them.  Observables are pure, computation of an observable does not have side effects.
                    </aside>
                </section>
                <section>
                    <p>A basic observable could be:</h2>
                    <ul>
                        <li>User tap events on a specific button</li>
                        <li>A network request</li>
                        <li>A database operation</li>
                        <li>Scroll offset in a scroll view as a user swipes</li>
                        <li>A timer</li>
                        <li>Anything!</li>
                    </ul>
                    <aside class="notes">Any kind of sequence of events can be modelled as an observable. It is not limited to certain kinds of operations. A core aspect of Rx is the ability to easily define new observables, which we'll get into later</aside>
                </section>
                <section>
                    <h2>Subscriptions</h2>
                   <aside class="notes">
                       As observables are pure, by themselves they're not incredibly useful to our users. They would just see white screens. Then probably rate the app 1 star. Not good.
                       To do some work based on our observable, we need to subscribe to it. In fact an observable wont even be computed unless it is subscribed to.
                        Subscribing to an observable is the process of attaching an observer, so that it recieves a notification of each new value emitted by the observable.
                        This is where your side effects will live.
                    </aside>
                    <pre><code class="hljs swift">
button.rx.tap //This is an observable
    .subscribe(onNext: { present(viewController: myAlert) }) //this is a side effect 
                    </code></pre> 
                </section>
                <section>
                    <h2>Observable operators</h2>
                    <img src="images/map.png" />
                    <aside class="notes">The observer pattern itself is nothing new. However Rx means Reactive extensions, and its at the x where things get interesting. Each Rx implementation ships with a variety of functional operators which can be applied to observables. These operators allow you to transform observables and combine them with each other in various ways, providing the building blocks for a functional and declarative codebase.</aside>
                </section>
                <section>
                    <h2>In practice</h2>
                    <aside class="notes">So now lets see how this works in practice. Lets say we were to build a login screen. A pretty standard affair, it gathers the user's username and password, ships them off to a backend API, and displays the result.</aside>
                    <img src="images/coolpeopleclub.png" />
                </section>
                <section>
                    <h2>Done!</h2>
                    <pre><code class="hljs swift"> loginButton.rx.tap
            .withLatestFrom(
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            )
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
    }
</code></pre>
                </section>
                <section>
                    <pre class="manualcode">
        loginButton.rx.tap
            .withLatestFrom(
                <span class="highlight">Observable.combineLatest(nameField.rx.text, passwordField.rx.text)</span>
            )
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
</pre>
                </section>
                <section>
                    <h2>combineLatest</h2>
                    <img src="images/combineLatest.png" />
                </section>
                <section>
                    <pre class="manualcode">
        loginButton.rx.tap
            <span class="highlight">.withLatestFrom(</span>
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            <span class="highlight">)</span>
            .flatMapLatest { userAPI.login(user: $0, password: $1) }
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
</pre>
                </section>
                <section>
                    <h2>withLatestFrom</h2>
                    <img src="images/withLatestFrom.png" />
                </section>
                <section>
                    <pre class="manualcode">
        loginButton.rx.tap
            .withLatestFrom(
                Observable.combineLatest(nameField.rx.text, passwordField.rx.text)
            )
            <span class="highlight">.flatMapLatest { userAPI.login(user: $0, password: $1) }</span>
            .map { $0.isSuccess ? "Success!" : "Failure" }
            .bindTo(resultField.rx.text)
            .disposed(by: disposables)
</pre>
                </section>
                <section>
                    <h2>flatMap/Latest</h2>
                    <img style="background: white;" src="images/flatMap.png" />
                </section>
                <section>
                    <h2>A functional reactive video player</h2>
                    <img src="images/videoplayer.png" style="height: 70%; width: auto;" />
                    <aside class="notes">Ok now lets move on to a more advanced example... like a workout video player. 
                    So the video player in this app, it has more than a few things going on. At the bottom of the pile you have the workout videos,
                    which is essentially the iOS AVPlayer widget being fed a playlist of streams to play.
                    Then either below it or overlayed, depending on screen orientation, we have the hud, showing what exercise you're on, what rep within that exercise, and what's coming up next, among other things.
                    And in between exercises we display intro segments, displaying info about the upcoming exercise, while actually pausing the video player underneath.
                    </aside>
                </section>
                <section>
                    <aside class="notes">Ok so there's a lot going on at this screen at once. We want to build a screen which displays information derived from the current state of the video player.  This calls for a reactive UI. The iOS video player exposes a variety of notifications to make it possible to build one around it. Unfortunately iOS doesn't help us here in that it uses three different mechanisms to notify the developer of changes to the video player's state. This is a place where rx shines, as we can encapsulate each of the notification mechanisms in observables, providing us with both a consistent api, and a library of functional operators with which to build our reactive ui.</aside>
                    <div class="uncenter">
                        <h4>Key-value observable</h4>
                        <ul>
                            <li>currentItem</li>
                            <li>isMuted</li>
                            <li>volume</li>
                            <li>status</li>
                        </ul>
                        <h4>Registered callbacks</h4>
                        <ul>
                            <li>Reached time</li>
                            <li>Periodic time</li>
                        </ul>
                        <h4>Broadcast notifications</h4>
                        <ul>
                            <li>Reached end of item</li> 
                            <li>Failed to play</li>
                            <li>Player skipped time</li>
                        </ul>
                    </div>
                </section>
                <section>
                    <h2>KVO -> Observable</h2>
                    <pre><code class="hljs swift">
extension Reactive where Base: AVPlayer {
    public var currentItem: Observable&lt;AVPlayerItem&gt;{
        return observe(AVPlayerItem.self, "currentItem")
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>NSNotification -> Observable</h2>
                    <pre><code class="hljs swift">
extension Reactive where Base: AVPlayer {
    public var itemEnd: Observable&lt;NSNotification&gt; {
        return Observable.merge(
            notificationCenter.rx.notification(NSNotification.Name.AVPlayerItemDidPlayToEndTime),
            notificationCenter.rx.notification(NSNotification.Name.AVPlayerItemFailedToPlayToEndTime)
        )
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Callback -> Observable</h2>
                    <pre><code class="hljs swift">
extension Reactive where Base: AVPlayer {
    public func seekTime(scale: CMTime) -> Observable&lt;Double&gt; {
        return Observable.create { observer in
            let timeObserver = player.addPeriodicTimeObserver(forInterval: scale, queue: nil) {
                observer.on(.next($0.seconds))
            }
            return Disposables.create {
                player.removeTimeObserver(timeObserver)
            }
        }
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Now everything is simple</h2>
                <img src="images/everythingobservable.jpg" />
                </section>
                <section>
                    <aside class="notes">So this is how we would expose the name of the currently playing exercise.</aside>
                    <pre><code class="hljs swift">
class WorkoutPlayer {
    public lazy var currentExerciseName: Observable&lt;String&gt; = 
        Observable.combineLatest(self.workout, self.currentItem) { workout, currentItem in
            workout.exercises[currentItem.position].name
         }
}
            </code></pre>
                </section>
                <section>
                    <h2>The old fashioned way</h2>
                    <aside class="notes">As a comparison, here is the equivalent functionality implemented using plain old key value observing, as well as a delegate to notify the new exercise name. You can see that on top of outright being more code, we have to keep track of our two changing properties in variables. We all know that as the size and scale of the class increases, the number of variables that we need to track will increase inordinately with the data we want to derive.</aside> 
                    <pre><code class="hljs swift" style="font-size: 16px; line-height: 20px;">
protocol WorkoutPlayerDelegate {
    func exerciseNameChanged(name: String)
}

class WorkoutPlayer {
    var workout: Workout {
        didSet {
            updateCurrentExercise()
        }
    }
    var currentItem: WorkoutPlayerItem?
    
    func setupObserving() {
        let player = AVPlayer()
        addObserver(self, forKeyPath: #keyPath(player.currentItem), options: [.old, .new], context: nil)
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == #keyPath(player.currentItem) {
           currentItem = player.currentItem
           updateCurrentExercise()
        }
    }
    
    func updateCurrentExercise() {
        let exercise = workout.exercises[currentItem.position]
        delegate.exerciseNameChanged(name: exercise.name)
    }
    
    func unsetupObserving() {
        removeObserver(self, forKeyPath: #keyPath(player.currentItem))
    }
}

                    </code</pre>
            </div>
        </div>
        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script>
            Reveal.initialize({
                    controls: false,
                    progress: true,
                    history: true,
                    center: true,
                    transition: 'slide', // none/fade/slide/convex/concave/zoom
                    width: "95%",
                    height: "95%",
                    margin: 0,
                    // More info https://github.com/hakimel/reveal.js#dependencies
                    dependencies: [
                        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                        { src: 'plugin/zoom-js/zoom.js', async: true },
                        { src: 'plugin/notes/notes.js', async: true }
                    ]
            });
    </script>
</body>
</html>
